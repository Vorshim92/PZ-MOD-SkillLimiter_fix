---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lele.
--- DateTime: 01/02/23 19:11
--- function ISSkillProgressBar:renderPerkRect()
--- ISSkillProgressBar:updateTooltip(lvlSelected)
-- -----------------------------------------------------------------

--- Version 03-11-23 11:56

---@class SkillLimiter

require("lib/CharacterBaseObj")

local blockLevel = require("BlockLevel")
local characterMaxSkill = require("CharacterMaxSkill")
local codePerkDetails = require("CodePerkDetails")
local debugDiagnostics = require("lib/DebugDiagnostics")
local errHandler = require("lib/ErrHandler")
local modDataManager = require("lib/ModDataManager")
local characterPz = require("lib/CharacterPZ")
--temporary fix, remove later
local perkFactoryPZ = require("lib/PerkFactoryPZ")


-- @type CharacterBaseObj
local CreateCharacterMaxSkillObj -- = CharacterBaseObj:new()
local SkillLimiter = {}

---@type string
local characterMaxSkillModData = "characterMaxSkill"

-- **Create Character Max Skill and create ModData**
---@return CharacterBaseObj
--- - IsoGameCharacter : zombie.characters.IsoGameCharacter
function SkillLimiter.initCharacter()
    local player = getPlayer();
    --- **Init Part 1**
    CreateCharacterMaxSkillObj = CharacterBaseObj:new()

    ---@type table
    local characterMaxSkillTable -- = {}
    --- **Check if ModData exists**
    if player:getModData().skillLimiter and not table.isempty(player:getModData().skillLimiter) then
        print("SkillLimiter - ModData exists")
        --- **Read ModData, get all stats of the character**
        characterMaxSkillTable = player:getModData().skillLimiter

        --- **Decode ModData**
        CreateCharacterMaxSkillObj = codePerkDetails.decodePerkDetails(characterMaxSkillTable)
    else
        print("SkillLimiter - ModData not exists")
        --- **Init Part 2**

        --- **Get skill obj**
        CreateCharacterMaxSkillObj =
            characterMaxSkill.getCreateMaxSkill( debugDiagnostics.characterUpdate() )

        --- **Encode ModData**
        characterMaxSkillTable =
            codePerkDetails.encodePerkDetails(CreateCharacterMaxSkillObj)

        --- **Save ModData**
        player:getModData().skillLimiter = characterMaxSkillTable

    end
    return CreateCharacterMaxSkillObj
end

--- **Delete modData when character is death**
--- - Triggered when a player is killed.
---@param character IsoGameCharacter
---@return void
local function OnPlayerDeath(character)
    --- **Kill player**
    if getPlayer():isDead() then
        --- **Delete ModData**
        getPlayer():getModData().skillLimiter = nil
    end
end

--- **Check Level Max**
--- - Triggered when a player gains XP.
---@param character IsoGameCharacter
---@param perk PerkFactory.Perk
---@param level int
---@return void
--- - IsoGameCharacter : zombie.characters.IsoGameCharacter
--- - PerkFactory.Perk : zombie.characters.skills.PerkFactory.Perk
function SkillLimiter.AddXP(character, perk, level)

    --- **Check if character is null**
    if not character then
        errHandler.errMsg("SkillLimiter.AddXP(character, perk, level)",
                errHandler.err.IS_NULL_CHARACTERS)
        return nil
    end

    --- **Check if perk is null**
    if not perk then
        errHandler.errMsg("SkillLimiter.AddXP(character, perk, level)",
                errHandler.err.IS_NULL_PERK)
        return nil
    end

    --- **Check if level is null**
    if not level then
        errHandler.errMsg("SkillLimiter.AddXP(character, perk, level)",
                errHandler.err.IS_NULL_LEVEL)
        return nil
    end

    --- **Check if CreateCharacterMaxSkillObj is null**
    if not CreateCharacterMaxSkillObj then
        errHandler.errMsg("SkillLimiter.AddXP(character, perk, level)",
                " CreateCharacterMaxSkillObj " .. errHandler.err.IS_NULL)
        return nil
    end

    print("gli XP guadagnati sono: " .. level .. " e sono per: " .. perk:getName())
    -- fix loop 
    if level <= 0 then
        print("SkillLimiter: gli XP sono negativi quindi non continuo")
        return
    end

    blockLevel.calculateBlockLevel(character, perk, level, CreateCharacterMaxSkillObj)
end

function SkillLimiter.checkLevelMax(character, perk)
    local currentPerkLevel = characterPz.getPerkLevel_PZ(character, perk)
    print("checkLevelMax: livello attuale del perk: " .. currentPerkLevel .. " e nome del perk è : " .. perk:getName())
    local maxLevel = characterPz.EnumNumbers.TEN
    local result = false
    for _, v in pairs(CreateCharacterMaxSkillObj:getPerkDetails()) do
        if v:getPerk() == perk then
            print("checkLevelMax: dentro if v:getPerk() == perk")
            -- print("checkLevelMax: v:getCurrentLevel(): ", v:getCurrentLevel())
            print("checkLevelMax: v:getMaxLevel(): ", v:getMaxLevel())
            if currentPerkLevel == maxLevel then
                result = true
                return result
            end
        
            if currentPerkLevel >= v:getMaxLevel() then
                print("checkLevelMax: dentro if currentPerkLevel >= v:getMaxLevel() " .. currentPerkLevel .. " >= " .. v:getMaxLevel())
                result = true
            end
            break
        end
    end
    return result
end

--- **Init Character**
--- - Triggered after the start of a new game, and after a saved game has been loaded.
local function OnGameStart()
    CreateCharacterMaxSkillObj = SkillLimiter.initCharacter()
end

--- **Temp Migration for old DB save**
--- this function will be removed in the future, like 3-6months, just to be sure
local function fixMigration()
    if modDataManager.isExists(characterMaxSkillModData) then
        print("SkillLimiter: old DB in ModData exists")
        local temp = ModData.get(characterMaxSkillModData)

        -- Function to split a string by a separator (handles UTF-8 properly)
        local function splitString(str, sep)
            local t = {}
            local pattern = string.format("([^%s]+)", sep)
            for s in str:gmatch(pattern) do
                table.insert(t, s)
            end
            return t
        end

        -- Mapping of Italian skill names to English
        local skillNameMap = {
            ["Cucinare"] = "Cooking",
            ["Forma fisica"] = "Fitness",
            ["Forza"] = "Strength",
            ["Contundente"] = "Blunt",
            ["Ascia"] = "Axe",
            ["Corsa"] = "Sprinting",
            ["Passo leggero"] = "Lightfoot",
            ["Destrezza"] = "Nimble",
            ["Furtivit" .. string.char(224)] = "Sneak",
            ["Carpenteria"] = "Woodwork",
            ["Mira"] = "Aiming",
            ["Ricarica"] = "Reloading",
            ["Coltivazione"] = "Farming",
            ["Pesca"] = "Fishing",
            ["Costruire Trappole"] = "Trapping",
            ["Cercare Cibo"] = "PlantScavenging",
            ["Pronto Soccorso"] = "Doctor",
            ["Elettrica"] = "Electricity",
            ["Lavorazione metalli"] = "MetalWelding",
            ["Meccanica"] = "Mechanics",
            ["Lancia"] = "Spear",
            ["Manutenzione"] = "Maintenance",
            ["Lama corta"] = "SmallBlade",
            ["Lama lunga"] = "LongBlade",
            ["Contundente corto"] = "SmallBlunt",
            ["Sartoria"] = "Tailoring",
        }

        -- Create a set of allowed English skill names from skillNameMap values
        local allowedEnglishSkills = {}
        for _, v in pairs(skillNameMap) do
            allowedEnglishSkills[v] = true
        end

        local newSkillLimiter = {}

        -- Function to determine if data is in Italian or English
        local function isDataInItalian()
            local sampleEntry = temp["2"]
            if sampleEntry then
                local components = splitString(sampleEntry, "-")
                if #components >= 1 then
                    local skillNameRaw = components[1]:match("^%s*(.-)%s*$")
                    if skillNameRaw == ("Agilit".. string.char(224)) then
                        return true
                    elseif skillNameRaw == "Agility" then
                        return false
                    else
                        -- Check if skillNameRaw is in skillNameMap
                        if skillNameMap[skillNameRaw] then
                            return true
                        else
                            return false
                        end
                    end
                end
            end
            -- Default to Italian if unable to determine
            return true
        end

        local dataIsItalian = isDataInItalian()

        -- Inform about the detected language
        print("SkillLimiter: Data is in " .. (dataIsItalian and "Italian" or "English"))

        -- Now process the data
        for _, v in pairs(temp) do
            -- Split the string into components
            local components = splitString(v, "-")
            if #components == 4 then
                local skillNameRaw = components[1]
                local currentLevel = components[2]
                local maxLevel = components[3]
                local xp = components[4]

                -- Trim whitespace from skillNameRaw
                skillNameRaw = skillNameRaw:match("^%s*(.-)%s*$")

                local skillName
                if dataIsItalian then
                    -- Map the Italian skill name to English
                    skillName = skillNameMap[skillNameRaw]
                    if skillName then
                        newSkillLimiter[skillName] = {
                            currentLevel = tonumber(currentLevel),
                            maxLevel = tonumber(maxLevel),
                            xp = tonumber(xp),
                        }
                    else
                        -- Skill is not in the mapping; skip it
                        print("SkillLimiter: Skipping skill '" .. skillNameRaw .. "' during migration.")
                    end
                else
                    -- Data is in English, use skillNameRaw directly
                    skillName = skillNameRaw
                    -- Include only allowed English skills
                    if allowedEnglishSkills[skillName] then
                        newSkillLimiter[skillName] = {
                            currentLevel = tonumber(currentLevel),
                            maxLevel = tonumber(maxLevel),
                            xp = tonumber(xp),
                        }
                    else
                        print("SkillLimiter: Skipping skill '" .. skillName .. "' during migration.")
                    end
                end
            else
                print("SkillLimiter: Error parsing skill data: " .. v)
            end
        end

        player:getModData().skillLimiter = newSkillLimiter
        modDataManager.remove(characterMaxSkillModData)
        print("SkillLimiter: old DB in ModData removed and transferred to new DB in getModData().skillLimiter")
    else 
        print("SkillLimiter: old DB in ModData not exists")
    end
end

--- **Init Character**
--- - Triggered when a player is being created.
local function OnCreatePlayer(playerIndex, player)
    -- Start fixMigration temporary
    fixMigration()
    -- End fixMigration

    CreateCharacterMaxSkillObj = SkillLimiter.initCharacter()
end


Events.OnPlayerDeath.Add(OnPlayerDeath) -- disabled temporary for testing events
Events.AddXP.Add(SkillLimiter.AddXP)
Events.OnGameStart.Add(function ()
    --fix temporaneo per fixare gli xp negativi dei player, da tenere un mesetto nella mod, sperando venga applicato a più player possibili
    local player = getPlayer();
    for i = 0, Perks.getMaxIndex() - 1 do

        ---@type PerkFactory.Perks
        local perk = perkFactoryPZ.getPerk_PZ(Perks.fromIndex(i))

        ---@type int
        local level = characterPz.getPerkLevel_PZ(player, perk) 

        ---@type double
        local xp = characterPz.getXp(player, perk)

        local actualXp = xp - ISSkillProgressBar.getPreviousXpLvl(perk, level)
        if actualXp < 0 then
            player:getXp():setXPToLevel(perk, level)
        end
    end
    SyncXp(player)
    end)
      
Events.OnCreatePlayer.Add(OnCreatePlayer)





return SkillLimiter